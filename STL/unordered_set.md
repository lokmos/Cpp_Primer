# unordered_set

在STL中，`std::unordered_set` 是一个无序关联容器，其内部基于哈希表实现。

# 原理

`unordered_set`基于哈希表实现, 哈希表每个参数就是一堆`KV`, `unordered_set`只需要进行一层封装, 去掉`KV`中的`V`就可以了

# 补充

1. `std::unordered_set` 和 `std::set` 有什么区别？
   - 主要区别在于内部数据结构和性能特性。`std::set` 基于红黑树实现，保持元素排序，而 `std::unordered_set` 基于哈希表，元素没有特定顺序。因此，`std::unordered_set` 通常提供更快的插入、删除和查找操作，但不支持顺序访问和范围查询。
2. 如何处理 `std::unordered_set` 中的冲突？
   - `std::unordered_set` 通过链地址法处理哈希冲突。当两个元素的哈希值相同并映射到同一存储位置时，这些元素会被存储在同一存储桶中的链表里。查找元素时，首先计算其哈希值，然后遍历对应存储桶中的链表。
3. 如何自定义 `std::unordered_set` 中元素的哈希函数和相等函数？
   - 在声明 `std::unordered_set` 时，可以提供自定义的哈希函数和相等谓词类型作为模板参数。自定义哈希函数必须是一个接受单个参数（存储在容器中的元素类型）并返回其哈希值的函数。自定义相等函数用于比较两个元素是否相等。
4. `std::unordered_set` 的迭代器是什么类型？它们是如何受到哈希表修改的影响？
   - `std::unordered_set` 提供了正向迭代器，包括常量和非常量版本。迭代器遍历哈希表的存储桶，然后遍历每个存储桶中的链表。增加或删除元素可能会导致存储桶重新哈希，这可能会使现有迭代器失效。然而，删除迭代器当前指向的元素是安全的。
5. 如何优化 `std::unordered_set` 的性能？
   - 优化 `std::unordered_set` 的性能通常涉及选择合适的哈希函数，以减少冲突并保持元素分布均匀。可以通过调用 rehash 方法来增加存储桶的数量，或使用 reserve 方法来提前分配足够的存储空间，以减少重哈希操作的次数。