# HashTable

## 原理

1. **基础**
   - 哈希表是一种通过哈希函数将键映射到索引的数据结构。
   - 哈希函数负责将任意大小的输入映射到固定大小的输出，即哈希值。这个哈希值用作在数组中存储键值对的索引。
2. **冲突解决**
   - 可以使用链地址法解决冲突，即在哈希表的每个槽中维护一个链表，将哈希值相同的元素存储在同一个槽中的链表中。
3. **扩容与再哈希**
   - 为了避免哈希表中链表过长导致性能下降，会在需要时进行扩容。
   - 扩容过程涉及到重新计算所有元素的哈希值，并将它们分布到新的更大的哈希表中。这一过程称为`rehashing`。
4. **性能优化**
   - 使用二次哈希函数、空间配置器、内存池等，以减小内存分配的开销，提高访问速度。
5. **并发与多线程安全**
   - 多线程哈希表的实现通常会考虑并发性和多线程安全性，通过锁或其他机制来保护共享的数据结构。

![img](assets/202404031653073.png)



# 和标准库的区别

实现的哈希表是一个简化版的哈希表，它使用链表来处理哈希冲突。这种方法也被称为分离链接法。以下是我们的实现与标准模板库（STL）中的`std::unordered_set`或`std::unordered_map`的一些区别：

1. **模板参数**
   - 我们的实现只接受键类型`Key`和哈希函数`Hash`作为模板参数。
   - STL的`std::unordered_set`和`std::unordered_map`有更多模板参数，如键的类型、值的类型、哈希函数、键的相等函数、分配器等。
2. **负载因子和自动重哈希**
   - 我们的实现在负载因子超过0.75时自动重哈希并且只能增加到当前大小的两倍。
   - STL的哈希表容器提供更多灵活性，可以调整负载因子，并且有更复杂的重哈希策略。
3. **内存分配**
   - 我们的实现使用`std::list`来管理冲突，这会导致多次单独的内存分配。
   - STL通常使用更高效的内存分配策略，比如预分配内存池来减少分配次数和提升性能
4. **迭代器支持**
   - 我们的实现没有提供迭代器支持。
   - STL提供了完整的迭代器支持，允许用户方便地遍历容器中的元素。
5. **功能**
   - 我们的哈希表实现了基础的插入、删除和查找功能。
   - STL的哈希表容器提供了更丰富的接口，如`emplace`, `count`, `bucket`, `bucket_count`, `bucket_size`, `load_factor`, `max_load_factor`, `rehash`, `reserve`等。
6. **异常安全**
   - 我们的实现没有显示地处理异常安全性问题。
   - STL的实现通常保证基本的异常安全性，并在某些操作中提供强异常安全性保证。
7. **优化**
   - 我们的实现是一个基本的哈希表，可能没有针对性能进行优化。
   - STL的实现被高度优化以提供良好的性能，特别是在大数据量下。



# 补充

1. **什么是哈希表？它是如何工作的？**
   - 哈希表是一种使用哈希函数组织数据，以便快速插入和搜索的数据结构。它通过将键映射到表中的位置来存储键值对。哈希函数将每个键转换为哈希表中的索引，该索引决定了键值对在表中的存储位置。如果两个键映射到同一个索引，就会产生冲突，这通常通过链表或开放寻址法来解决。
2. **哈希冲突是什么？如何处理哈希冲突？**
   - 哈希冲突发生在不同的键通过哈希函数映射到哈希表的同一位置时。处理哈希冲突的方法有：
     - **链表法（分离链接法）**：在每个哈希表索引上维护一个链表，所有映射到该索引的元素都会被存储在链表中。
     - **开放寻址法**：如果发生冲突，就会寻找下一个空闲的哈希表索引。
     - **双重哈希**：使用一系列哈希函数而不是单一哈希函数来确定元素的存储位置。
3. **如何选择一个好的哈希函数？**
   - 一个好的哈希函数应该满足以下条件：
     - 快速计算。
     - 哈希值均匀分布，以减少冲突。
     - 一致性：相同的输入总是产生相同的输出。
     - 不同的输入应尽可能映射到不同的输出。
4. **什么是负载因子？对哈希表有什么影响？**
   - 负载因子是哈希表中已存储元素数量与位置总数的比率。它是衡量哈希表满程度的指标。当负载因子过高时，冲突的可能性增加，这会降低哈希表的性能。因此，通常在负载因子达到一定阈值时，哈希表会进行扩容（即重哈希）来增加存储位置，从而减少冲突和维护操作的效率。
5. **解释重哈希（rehashing）。何时以及为什么需要重哈希？**
   - 重哈希是在哈希表的负载因子超过预定的阈值时，增加哈希表容量并重新分配现有元素的过程。这个过程需要计算每个元素的新哈希值，并将它们移动到新表中的正确位置。重哈希可以帮助减少冲突和维持操作的快速性能。
6. **在哈希表中插入、删除和搜索操作的复杂度是多少？**
   - 理想情况下，即没有发生冲突或冲突非常少时，插入、删除和搜索操作的时间复杂度为O(1)。但是，在最坏的情况下，如果所有的键都映射到同一索引，则这些操作的时间复杂度会退化到O(n)，其中n是哈希表中元素的数量。使用良好的哈希函数和冲突解决策略可以帮助保持操作的平均时间复杂度为接近O(1)。
7. **如何解决哈希表的扩容问题？**
   - 扩容通常发生在哈希表的负载因子超过预定阈值时。解决方案通常包括：
     - **创建一个更大的哈希表**：创建一个容量更大的新哈希表。
     - **重新哈希所有元素**：将所有现有的元素重新计算哈希值并插入到新的哈希表中。
     - **逐步迁移**：在某些实现中，可以逐步迁移元素到新表，分摊重哈希的成本到多次插入操作中。
8. **如何确保哈希表的线程安全？**
   - 确保哈希表的线程安全可以通过以下方式之一：
     - **互斥锁**：使用互斥锁来同步对哈希表的访问。每次一个线程访问哈希表时，它都需要先获取锁。
     - **读写锁**：如果读操作远多于写操作，使用读写锁可以提高性能，因为它允许多个线程同时读取，但写入时需要排他访问。
     - **原子操作**：对于简单的操作，可以使用原子操作来避免使用锁。
     - **细粒度锁**：而不是对整个哈希表加锁，可以对哈希表的一部分（例如单个桶或链表）加锁，以减少锁的粒度。
9. **有哪些常见的哈希表实现问题？**
   - 常见的哈希表实现问题包括：
     - **内存使用不当**：如果哈希表过大或者存在许多空桶，可能会导致内存浪费。
     - **冲突处理不佳**：如果冲突没有得到有效处理，会严重影响哈希表的性能。
     - **哈希函数选择不当**：一个不好的哈希函数可能会导致频繁的冲突。
     - **扩容代价高**：重哈希是一个代价很高的操作，如果发生得太频繁，可能会严重影响性能。